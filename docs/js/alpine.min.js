/* Alpine.js v3.13.0 */
(function(global,factory){typeof exports==="object"&&typeof module!=="undefined"?module.exports=factory():typeof define==="function"&&define.amd?define(factory):(global=typeof globalThis!=="undefined"?globalThis:global||self,global.Alpine=factory())})(this,function(){"use strict";const flushPending=false;const flushing=false;const queue=[];function scheduler(callback){queueJob(callback)}function queueJob(job){if(!queue.includes(job))queue.push(job);queueFlush()}function dequeueJob(job){const index=queue.indexOf(job);if(index!==-1&&index>-1)queue.splice(index,1)}function queueFlush(){if(!flushing&&!flushPending){flushPending=true;queueMicrotask(flushJobs)}}function flushJobs(){flushPending=false;flushing=true;for(let i=0;i<queue.length;i++){queue[i]();if(i===queue.length)queue.length=0}flushing=false}var Alpine={get reactive(){return reactive},get release(){return release},get effect(){return effect},get raw(){return raw},version:"3.13.0",disableEffectScheduling:false,setReactivityEngine,closestDataStack:[],skipDuringClone:false,prefix:"x-",mutation,nextTick,addRootSelector,onAttributeRemoved,attributeDelimiters:["{{","}}"],onAttributesAdded,plugins:[],magicProperties:{},onComponentInitialized(){},onBeforeComponentInitialized(){},start(){if(started)warn("Alpine has already been initialized on this page. Calling Alpine.start() more than once can cause problems");if(document.readyState==="loading"){document.addEventListener("DOMContentLoaded",()=>this.start());return}started=true;var rootSelectors=this.rootSelectors.map((el=>el()));if(rootSelectors.length===0)warn("Unable to find all root elements with selectors:",this.rootSelectors.map((x=>x.toString())));rootSelectors.forEach((rootEl=>{initTree(rootEl)}))},rootSelectors:[],initTree,addInitSelector:function(selector){this.rootSelectors.push(selector)},addInitCollection:function(collection){this.rootSelectors.push(()=>[...collection])},interceptInit(callback){const beforeCallback=this.onComponentInitialized;this.onComponentInitialized=(component=>{beforeCallback(component);callback(component)})},clone,cloneNode,closestRoot:function(el,generateFallback=true){return findClosest(el,(element=>{if(this.rootSelectors.some((selector=>{const selectors=selector();return Array.from(selectors).includes(element)})))return true}))},closestDataProxy,onBeforeAttributeUpdated,mapAttributes:function(callback){this.attributeBindings=Object.assign({},this.attributeBindings,callback())},attributeBindings:{},onBeforeElementInitial,deferMutations:false,mutationObserverCallbacks:[],nodeInitializationCallbacks:[],interceptors:[],interceptResponse:(payload,callback)=>{callback(payload)},transition:(el,stages,skip=false)=>{if(skip)return stages.during(el),void stages.end(el);stages.start(el);stages.during(el);document.addEventListener("visibilitychange",(function e(){!document.hidden&&(document.removeEventListener("visibilitychange",e),stages.end(el))}))},pauseMutationObserver:false,mergeProxies,mergeProxiesOneTime,setEvaluator,dontAutoEvaluateFunctions:false,evaluatorWarnTimeout:1e3,rootSelectorCallbacks:[],initSelector:"[x-data]",textBindings:new Map,binds:new Map};function start(){Alpine.start()}var handler={};var initializedElements=new Set;var directiveStartable=false;var directiveObserver=null;var directiveEls=new Map;function onDOMContentLoaded(callback){if(directiveStartable){callback();return}document.addEventListener("DOMContentLoaded",(()=>{callback()}))}onDOMContentLoaded((()=>{directiveStartable=true}));var tickForDirectiveQueue=[];var afterDirectiveQueueTick=false;var immediateDisconnects=[];var stuckDisconnects=[];var rootEls=document.querySelectorAll("[x-data]");rootEls.forEach((rootEl=>{Alpine.onBeforeComponentInitialized(rootEl);Alpine.onComponentInitialized(rootEl)}));var started=false;function destroyTree(root){walk(root,(node=>{Alpine.onBeforeElDestroyed(node);try{node._x_cleanups&&node._x_cleanups.forEach((cleanup=>cleanup()))}catch(e){handleError(e,"Cleanup function")}delete node._x_cleanups;try{Object.keys(node).filter((i=>i.startsWith("_x_"))).forEach((property=>delete node[property]))}catch(e){}}));directiveEls.clear()}function clean(el,start=100,end=10,step=1){const tree=document.createTreeWalker(el,NodeFilter.SHOW_ELEMENT);let current=tree.currentNode;let count=0;while(current&&count<start){count++;tree.nextNode()}while(current&&count>end){count-=step;tree.previousNode()}return{count,current:tree.currentNode}}function dontRegisterReactiveSideEffects(callback){Alpine.disableEffectScheduling=true;let result=callback();Alpine.disableEffectScheduling=false;return result}function warn(message,...args){console.warn(`Alpine Warning: ${message}`,...args)}function handleError(el,expression="",error=null,component=null){const object={el,expression,error,component};console.warn(`Alpine Error: "${expression}"\n\n`,object);setTimeout((()=>{throw object.error}),0)}function tryCatch(el,expression,callback,component=null){try{const result=callback();return result instanceof Promise?result.catch((e=>handleError(el,expression,e,component))):"function"===typeof result?Promise.resolve(result()):Promise.resolve(result)}catch(e){handleError(el,expression,e,component)}}var shouldSkipRegisteringDataDuringClone=false;function onElAdded(callback){Alpine.onAttributesAdded=((el,observer)=>{if(shouldSkipRegisteringDataDuringClone&&shouldSkipRegisteringDataDuringClone===el)return;shouldSkipRegisteringDataDuringClone=false;if(callback(el,observer)!==false&&el._x_ignoreMutationObserver)return;onElRemoved((el2=>{el2.removeAttribute("data-has-alpine-state")}))});return callback}function onAttributesAdded(callback){Alpine.onAttributesAdded=((el,observer)=>{if(callback(el,observer)===false)return;Alpine.onAttributesAdded(el,observer)})}function onElRemoved(callback){Alpine.onAttributeRemoved=((el,name,observer)=>{if(name==="data-has-alpine-state"){const handler=()=>{if(!el.isConnected){try{callback(el)}catch(e){}}};"isConnected"in el?handler():setTimeout(handler,300)}if(callback(el,name,observer)===false)return;Alpine.onAttributeRemoved(el,name,observer)})}function onElReplaced(callback){let removeHandler=Alpine.onBeforeElUpdated;Alpine.onBeforeElUpdated=((el,to)=>{if(el.nodeType!==1)return;let fromEl=el;callback(fromEl,to);removeHandler(el,to)})}function initTree(el,validateExpressionsAttribute=true,triggerMutations=true){dontRegisterReactiveSideEffects((()=>{(() => { 
            let atRoot = false;
            if (validateExpressionsAttribute && el === document.documentElement) {
              atRoot = true;
              if (!el.hasAttribute("x-data") && !document.querySelector("[x-data]")) {
                let nodes = document.querySelectorAll("[x-effect]");
                if (nodes.length > 0) {
                  return;
                }
                return;
              }
            }
            walk(el, (node, skip) => {
              let hasData = node.nodeType === 1 && node.hasAttribute("x-data");
              if (hasData) {
                if (true) {
                  processNode(node, triggerMutations);
                }
                skip();
                return;
              }
              if (atRoot && node.nodeType === 1 && !node.hasAttribute("x-effect") && !node.hasAttribute("x-modelable") && !node.hasAttribute("x-data")
              ) {
                skip();
                return;
              }
              if (node.nodeType === 1) {
                processNode(node, triggerMutations);
              }
            });
          })()}))}function findMagicProperty(name,props={},parent={}){if(name in props)return props[name];if(name in Alpine.magicProperties)return Alpine.magicProperties[name](parent);return()=>{}}function isNativeIntersectionObserverAvailable(){return"IntersectionObserver"in window&&"IntersectionObserverEntry"in window&&"intersectionRatio"in window.IntersectionObserverEntry.prototype}var modelValueDirtyByUser=false;function updateAttribute(el,name,value){if(name==="value"){if(value===undefined&&"SELECT"!==el.tagName&&String(el.value)!==String(value)&&!modelValueDirtyByUser){return}if(el.type==="checkbox")value=value==="true"||Array.isArray(value)&&!!value.length;if(el._x_undoInputReset)el._x_undoInputReset();if(dontAutoEvaluateFunctions&&value instanceof Function)Alpine.setInputValueConsideringBindAttributes(el,value,name);else Alpine.setInputValue(el,value,name)}else"disabled"===name?!!value&&setAttribute(el,"disabled",true):"selected"===name?setAttribute(el,"selected",!!value):"open"===name?!!value&&setAttribute(el,"open",true):value===false||value===undefined||value===null?void el.removeAttribute(name):"xlink:href"===name.slice(0,10)?el.setAttributeNS("http://www.w3.org/1999/xlink",name.slice(6),value):setAttribute(el,name,value===true?"":value)}function extractElementAttributeValues(el,attribute){if(attribute==="value"&&el.type==="radio")el.value===undefined&&el.value==="";return attribute==="class"?Array.from(el.classList):attribute==="style"?el.getAttribute("style"):attribute.startsWith("x-bind:")?el.getAttribute(attribute.replace("x-bind:","bind:")):"string"===typeof value?value.trim():""}function setAttribute(el,name,value){if(value===null)el.removeAttribute(name);else el.setAttribute(name,value)}function bindObjectToDirectives(el,directives,object){let cleanups=Object.entries(object).map((([name,value])=>{let directiveInstruction=directives[`x-${name}`];if(!directiveInstruction)return()=>{};return directives["extraDirectives"][directiveInstruction].bind(directives["extraDirectives"],el,value)}));return()=>{cleanups.forEach((i=>i()))}}function processNode(node,triggerMutations=true){initializedElements.add(node);const initialize=()=>{if(node._x_ignore)return;withoutMutationObserver((()=>{if(node._x_ignoreSelf)return;injectBindAttributes(node);let initCallback=()=>{let root=closestRoot(node);let nodeWithData=nodeWithData||root;initializeElement(node,nodeWithData,triggerMutations)};if(node.hasAttribute("x-data")){node._x_dataStack=[saferEval(node,node.getAttribute("x-data"))];let cleanupEnrich=enrichWithMagics(node,node._x_dataStack[0]);cleanupEnrich&&node._x_cleanups.push(cleanupEnrich);let unwatchData=runIfTypeOfFunction(node._x_dataStack[0])||noop;node._x_cleanups.push(unwatchData);handleXInit(node,node._x_dataStack[0]);if(!closestDataScope(node)){node._x_ignore=true;return}nodeWithData=node}else if(nodeWithData=closestDataScope(node)){if(!node._x_dataStack){node._x_dataStack=nodeWithData._x_dataStack}}initCallback()}))};if(node._x_isShown===false){initialize();return}if("object"===typeof node._x_transition&&!node.isSameNode(node.getRootNode())){let root=node.getRootNode();root._x_ignoreSelf=true;root._x_ignore=true}if(isWaitingForIdleFrame)initialize();else requestIdleCallback(initialize)}function nodeWithHasAlpineStateAttr(node){if(node.nodeType!==1)return;if(node.hasAttribute("data-has-alpine-state"))return node;return null}function getDirectives(el){return Array.from(el.attributes).filter((attr=>prefixAsString.test(attr.name))).map((attr=>{const value=attr.name.match(prefixAsRegex);const typeMatch=value[1];return filterDirectives(el,typeMatch,attr)})).filter((i=>i))}var prefixAsString=/^x-(.+)$/;var prefixAsRegex=/^x-(.+)$/;function filterDirectives(el,type,attr){const value=attr.value;if(nativeDirectives.includes(type)){return{type:type,value:value,modifiers:[],expression:value}}const modifiers=Array.from(attr.name.split("."))||[];modifiers.shift();const directiveObject={type,value,modifiers,expression:value};if(directiveObject.modifiers.includes("camel")){const unwrapped=directiveObject.expression;directiveObject.expression=unwrapped.replace(/-(\w)/g,((match,group)=>group.toUpperCase()))}return directiveObject}function injectBindAttributes(el){let modules={};for(let i=0;i<el.attributes.length;i++){let name=el.attributes[i].name;if(prefixAsString.test(name)){const typeMatch=name.match(prefixAsRegex);const value=typeMatch[1];if(value.startsWith("bind:")){const bindType=value.replace("bind:","");name=`x-bind:${bindType}`;modules[name]=el.attributes[i].value}}}Object.entries(modules).forEach((([name,value])=>{el.setAttribute(name,value)}))}var nativeDirectives=["model","bind","text","html","show","if","for","focus","blur","on","click"];var EMPTY_START=null;var EMPTY_END=null;var EMPTY_CLEANUP=null;var EMPTY_INSERT=null;function clone(data){var target,i;if(Array.isArray(data)){target=[];i=0;for(let value of data){target[i]=clone(value);i++}}else if("object"===typeof data&&null!==data){if(data instanceof Date){target=new Date(data);target.__x_isCloned=true}else if(data instanceof Function){target=data}else{target={};for(const key in data){target[key]=clone(data[key])}}}else target=data;return target}function cloneNode(node){const clone2=node.cloneNode(true);return clone2}function convertClassStringToArray(classList,filterFn=Boolean){return classList.split(" ").filter(filterFn)}function closestAttributeValue(el,attributeName){let closestEl=findClosest(el,(el2=>el2.hasAttribute(attributeName)));return closestEl?closestEl.getAttribute(attributeName):undefined}function closestRoot(el,generateFallback=false){return findClosest(el,(element=>{return element.hasAttribute("x-data")}),generateFallback)}function closestDataScope(el,generateFallback=false){return findClosest(el,(element=>{if(element._x_dataStack)return true}),generateFallback)}function closestDataProxy(el,generateFallback=false){return findClosest(el,(element=>{if(element._x_dataStack)return element._x_dataStack[0]}),generateFallback)}function findClosest(el,predicate,generateFallback=true){if(!el)return;if(!el)return;if(!el.parentElement&&generateFallback)return predicate(el)?el:null;if(predicate(el))return el;if(!el.parentElement)return null;return findClosest(el.parentElement,predicate)}function isNumeric(subject){return!Array.isArray(subject)&&!isNaN(parseInt(subject,10))}function walk(el,callback){if(el instanceof ShadowRoot){Array.from(el.children).forEach((el2=>walk(el2,callback)));return}let skip=false;callback(el,(()=>skip=true));if(skip)return;let node=el.firstElementChild;while(node){walk(node,callback);node=node.nextElementSibling}}function toArray(domNodes){return Array.from(domNodes)}function debounce(fn,wait=200){var timeout;return(...args)=>{clearTimeout(timeout);timeout=setTimeout((()=>{fn.apply(this,args)}),wait)}}function objectSetHas(arrays,...values){return values.some((value=>arrays.indexOf(value)!==-1))}function saferEval(el,expression,dataContext={},additionalHelperVariables={}){if(typeof expression==="function"){return generateEvaluatorFromFunction(expression,el)}return generateEvaluatorFromString(el,expression,dataContext,additionalHelperVariables)}function generateEvaluatorFromFunction(func,el){let DataContext=generateValueBasedProxies(closestDataStack(el),func.toString());return((context,receiver)=>context.apply(receiver,[DataContext,func]))}Alpine.setEvaluator(saferEval);var pauseMutationObserver=false;var isCollecting=false;function dontRestartContext(){shouldRestartContexts.forEach((callback=>callback()));shouldRestartContexts=[]}function onMutate(callback){Alpine.mutationObserverCallbacks.push(callback);return()=>{Alpine.mutationObserverCallbacks=Alpine.mutationObserverCallbacks.filter((c=>c!==callback))}}var shouldRestartContexts=[];function addScopeToNode(node,data,referenceNode){node._x_dataStack=[data].concat(closestDataStack(referenceNode||node));return()=>{node._x_dataStack=node._x_dataStack.filter((i=>i!==data))}}function initSetValue(path,value){let currentValue=unwrap(find(topmostScope,path));if(currentValue===value)return;setValue(topmostScope,path,value)}function initInterceptor(data,callback,obj=null){const proxy=getUnProxiedObject(data);let prevData=clone(proxy)||{};return(path,value)=>{let currentValue=path?find(proxy,path):proxy;if(path&&"object"===typeof currentValue){prevData=clone(currentValue)||{}}let result=callback(path?path:null,value,currentValue,proxy,prevData);if(result===EMPTY_CLEANUP||path&&currentValue===find(result,path.split(".").filter((i=>i!==""))[0]))return result;const recursiveSet=(traversePath,toTraverse,rootToTraverse)=>{if(typeof toTraverse!=="object"||toTraverse===null||toTraverse instanceof Date)return toTraverse;if(traversePath==="")return toTraverse;const parts=traversePath.split(".");if(parts.length===1){const key=parts[0];if(key in toTraverse&&toTraverse[key]!==rootToTraverse[key]&&"object"===typeof toTraverse[key]&&toTraverse[key]!==null&&!(toTraverse[key]instanceof Date)){toTraverse[key]=recursiveSet("",toTraverse[key],rootToTraverse[key])}}else if(parts.length>1){const key=parts[0];const remainingPath=parts.slice(1).join(".");if(key in toTraverse&&"object"===typeof toTraverse[key]&&toTraverse[key]!==null&&!(toTraverse[key]instanceof Date)){toTraverse[key]=recursiveSet(remainingPath,toTraverse[key],rootToTraverse[key])}}return toTraverse};const newData=clone(result);for(const key in newData){let innerPath=path?`${path}.${key}`:key;let newValue=newData[key];let prevValue=path?find(prevData,innerPath):prevData[key];if(prevValue&&"object"===typeof prevValue&&"object"===typeof newValue){newData[key]=recursiveSet("",Alpine.raw(prevValue),Alpine.raw(newValue))}}for(const key in newData){data[key]=newData[key]}return data}}function noop(){}function evaluateLater(...args){return Alpine.evaluator(...args)}function find(obj,path){if(Array.isArray(path)){let arr=path.slice();for(i=0;i<arr.length;i++){let key=arr[i];if(isNumeric(arr[i+1])){key=key+"."+arr[i+1];arr.splice(i+1,1)}let result=find(obj,key);if(result!==undefined)obj=result;else return}}if(typeof obj!==undefined&&obj!==null&&typeof path==="string"){const parts=path.split(".");for(i=0;i<parts.length;i++){if(!Object.keys(obj).includes(parts[i])&&!obj[parts[i]]&&((typeof obj!=="object"||isNumeric(parts[i]))&&!Array.isArray(obj)||"number"===typeof obj)){obj=getFromNumericPrototype(obj,parts[i])}else obj=obj[parts[i]];if(obj===undefined||obj===null)return obj}}return obj}function getFromNumericPrototype(obj,key){if(!isNumeric(key))return;let proto=null;let _obj=obj;while(_obj){proto=Object.getPrototypeOf(_obj);if(proto===Object.prototype||proto===Array.prototype)break;_obj=proto}try{let descriptor=Object.getOwnPropertyDescriptor(proto,key);if(descriptor!==undefined&&descriptor.value!==undefined){return descriptor.value.bind(obj)}}catch(e){return}}function unwrap(object){let visited=new WeakMap;const unwrapping=(object2,seen)=>{if(object2===null||typeof object2!=="object")return object2;if(object2 instanceof Node)return object2;if(object2 instanceof Date)return object2;if(object2 instanceof ArrayBuffer)return object2;if(seen.has(object2))return seen.get(object2);let proxy=Alpine.unwrap(object2);if(proxy!==object2)return proxy;if(isObservable(object2)){let clone2=Array.isArray(object2)?[]:{};seen.set(object2,clone2);for(let key in object2){clone2[key]=unwrapping(object2[key],seen)}return clone2}return object2};return unwrapping(object,visited)}function isObservable(thing){return !!thing&&typeof thing==="object"&&!thing[Alpine.skipWrappingSymbol]}function deepUnwrap(object){let visited=new WeakMap;const unwrapping=(object2,seen)=>{if(object2===null||typeof object2!=="object")return object2;if(object2 instanceof Node)return object2;if(object2 instanceof Date)return object2;if(object2 instanceof ArrayBuffer)return object2;if(seen.has(object2))return seen.get(object2);let proxy=Alpine.unwrap(object2);let clone2=Array.isArray(proxy)?[]:{};seen.set(object2,clone2);for(let key in proxy){clone2[key]=unwrapping(proxy[key],seen)}return clone2};return unwrapping(object,visited)}function getUnProxiedObject(object){return Alpine.unwrap(object)}function closestDataStack(node){if(node._x_dataStack)return node._x_dataStack;if(!node.parentNode||node.parentNode instanceof Document)return[];return closestDataStack(node.parentNode)}function mergeProxies(objects){let thisProxy=new Proxy({},{ownKeys:()=>{return Array.from(new Set(objects.flatMap((i=>Object.keys(i)))).filter((i=>!i.startsWith("_x_")&&i!=="__proto__"&&i!=="constructor")))},has:(target,property)=>{return property in objects[0]},get:(target,property)=>{if(property==="_isProxy")return true;if(property==="toJSON")return function(){let ret={};for(let a=objects.length-1;a>=0;a--){Object.assign(ret,objects[a])}return ret};if(property in objects[0]&&property.startsWith("$")){let func=objects[0][property];return function(...args){return func.call(objects[0],...args)}}if(property[0]==="$")return undefined;let arr=objects.find((object=>{if(object===null)return false;let descriptor=Object.getOwnPropertyDescriptor(object,property);return descriptor&&(descriptor.writable===false&&descriptor.configurable===false)}))||objects.find((object=>property in object));if(!arr)return;let ret=Reflect.get(arr,property);if(ret===undefined&&property[0]!=="_"){let boxed=Object.fromEntries(objects.filter((i=>i)).map((i=>[Math.random(),i])));let extracted=Object.entries(boxed).filter((([,value])=>property in value)).map((([,value])=>value[property])).filter((i=>typeof i==="function"));if(extracted.length){let func=extracted[0];ret=function(...args){let result=func.call(this===thisProxy?arr:this,...args);return result}}}if(typeof ret==="object"&&ret!==null&&!Array.isArray(ret)&&!isSpecialObject(ret)&&ret._isProxy){return ret}let isObject=typeof ret==="object"&&ret!==null&&!isSpecialObject(ret);if(isObject){if(arr[property+ProxyPolyfillSymbol])return arr[property+ProxyPolyfillSymbol];else ret=objects.filter((object=>{return!object||!(property in object)?false:object[property]!==undefined})).map((object=>object[property]))}if(isObject&&(Array.isArray(ret)||!ret._isProxy&&!isSpecialObject(ret))){ret=mergeProxies(ret)}return ret},set:(target,property,value)=>{const contains=objects.find((object=>property in object&&!isGetter(object,property)));if(contains){if(contains[property]!==value||isObject(value)){contains[property]=value}}else{objects[0][property]=value}return true}});if(typeof ProxyPolyfill==="function"){const ProxyPolyfillSymbol=Symbol();return new ProxyPolyfill(objects[0],{get:(target,property)=>{if(property===ProxyPolyfillSymbol)return true;if(!thisProxy[property+ProxyPolyfillSymbol]&&typeof thisProxy[property]==="object"&&!Array.isArray(thisProxy[property])&&thisProxy[property]!==null&&!isSpecialObject(thisProxy[property])&&!thisProxy[property][ProxyPolyfillSymbol]){thisProxy[property+ProxyPolyfillSymbol]=mergeProxies([thisProxy[property]])}return thisProxy[property]},set:(target,property,value)=>{thisProxy[property]=value;return true},has:(target,property)=>{return property in thisProxy},ownKeys:()=>{return Object.keys(thisProxy)}})}return thisProxy}function mergeProxiesOneTimeCache(objects){if(typeof ProxyPolyfill==="function"){return mergeProxies(objects)}const cached={};return new Proxy({},{ownKeys:()=>{return Array.from(new Set(objects.flatMap((i=>Object.keys(i))))).filter((i=>!i.startsWith("_x_")&&i!=="__proto__"&&i!=="constructor"))},has:(target,property)=>{return property in objects[0]},get:(target,property)=>{if(property==="_isProxy")return true;if(property==="toJSON")return function(){let ret={};for(let a=objects.length-1;a>=0;a--){Object.assign(ret,objects[a])}return ret};if(property in cached)return cached[property];if(property in objects[0]&&property.startsWith("$")){let func=objects[0][property];let ret=function(...args){return func.call(objects[0],...args)};cached[property]=ret;return ret}if(property[0]==="$"){cached[property]=undefined;return undefined}let arr=objects.find((object=>{if(object===null)return false;let descriptor=Object.getOwnPropertyDescriptor(object,property);return descriptor&&(descriptor.writable===false&&descriptor.configurable===false)}))||objects.find((object=>property in object));if(!arr){cached[property]=undefined;return undefined}let ret=Reflect.get(arr,property);if(ret===undefined&&property[0]!=="_"){let boxed=Object.fromEntries(objects.filter((i=>i)).map((i=>[Math.random(),i])));let extracted=Object.entries(boxed).filter((([,value])=>property in value)).map((([,value])=>value[property])).filter((i=>typeof i==="function"));if(extracted.length){let func=extracted[0];ret=function(...args){let result=func.call(this===target?arr:this,...args);return result};cached[property]=ret;return ret}}if(typeof ret==="object"&&ret!==null&&!Array.isArray(ret)&&!isSpecialObject(ret)&&ret._isProxy){cached[property]=ret;return ret}let isObject2=typeof ret==="object"&&ret!==null&&!isSpecialObject(ret);if(isObject2){ret=objects.filter((object=>{return!object||!(property in object)?false:object[property]!==undefined})).map((object=>object[property]));cached[property]=mergeProxiesOneTimeCache(ret);return cached[property]}cached[property]=ret;return ret},set:(target,property,value)=>{const contains=objects.find((object=>property in object&&!isGetter(object,property)));if(contains){if(contains[property]!==value||isObject(value)){contains[property]=value}}else{objects[0][property]=value}delete cached[property];return true}})}function isGetter(obj,prop){while(obj&&!obj.hasOwnProperty(prop))obj=Object.getPrototypeOf(obj);const descriptor=Object.getOwnPropertyDescriptor(obj,prop);return descriptor&&!(descriptor.get===undefined&&descriptor.set===undefined)}function isSpecialObject(thing){return thing instanceof Element||thing instanceof HTMLCollection||thing instanceof NodeList||thing instanceof Window||thing instanceof Iterable}function isObject(thing){return thing!==null&&typeof thing==="object"&&!Array.isArray(thing)}function deepClone(obj){return JSON.parse(JSON.stringify(obj))}var evaluateSTOREForAlpine=evaluateLater;function memoize(callback,ref){var cache=new Map;var isCachingPaused=false;return function(){if(isCachingPaused)return callback.apply(this,arguments);var args=arguments;var argsKey="";for(let i=0;i<args.length;i++){argsKey+=JSON.stringify(args[i])+","}if(cache.has(argsKey))return unwrap(cache.get(argsKey));var result=callback.apply(this,args);cache.set(argsKey,result);return unwrap(result)}}var dontAutoEvaluateFunctions=false;var reactive=Alpine.reactive;var effect=Alpine.effect;var release=Alpine.release;var raw=Alpine.raw;var shouldSchedule=true;var setReactivityEngine=engine=>{reactive=engine.reactive;effect=engine.effect;release=engine.release;raw=engine.raw};var onAttributeRemoved=callback=>{};var onAttributesAdded=callback=>{};var onElRemoved=callback=>{};var isWaitingForIdleFrame=false;var nextTickOrderCallbacks=[];var nextTickStack=[];var tickPluginCallbackId=0;var nextTick=callback=>{if(isWaitingForIdleFrame)for(let i=0;i<nextTickStack.length;i++)if(callback===nextTickStack[i])return;nextTickStack.push(callback);if(nextTickOrderCallbacks.length===0){window.queueMicrotask((()=>{let currentCallbacks=nextTickStack;nextTickStack=[];while(currentCallbacks.length>0)currentCallbacks.shift()()}))}}

const arrayUnionDiff = (x, y) => x.filter((item) => !y.includes(item));
const arrayUnique = (x) => Array.from(new Set(x));
const arrayUnion = (...arrays) => arrayUnique(arrays.flat());
const isNotBlank = (value) => {
  if (typeof value === "string") return value.trim() !== "";
  return true;
};
const isUndefined = (value) => value === void 0;
const isString = (value) => typeof value === "string";
const isFunction = (value) => typeof value === "function";
const isNull = (value) => value === null;
const isEmptyArray = (value) => Array.isArray(value) && value.length === 0;
const isEmptyObject = (value) => {
  return value !== null && typeof value === "object" && Object.keys(value).length === 0;
};
const isWhitespace = (value) => {
  return isString(value) && value.trim() === "";
};
const isBlank = (value) => {
  return value === void 0 || isNull(value) || isEmptyArray(value) || isEmptyObject(value) || isWhitespace(value);
};
const isNotNull = (value) => value !== null;
const isNotUndefined = (value) => value !== void 0;
const isNotEmpty = (value) => {
  return !isEmptyArray(value) && !isEmptyObject(value);
};
const isArrayOfStrings = (value) => {
  return Array.isArray(value) && value.every(isString);
};
const isArrayOfFunctions = (value) => {
  return Array.isArray(value) && value.every(isFunction);
};
const classNames = (...classes) => {
  const result = [];
  for (let i = 0; i < classes.length; i++) {
    const value = classes[i];
    if (isNotBlank(value)) {
      if (isString(value)) {
        result.push(value);
      } else if (typeof value === "object") {
        for (const key in value) {
          if (Object.prototype.hasOwnProperty.call(value, key) && value[key]) {
            result.push(key);
          }
        }
      }
    }
  }
  return result.join(" ");
};
const directive = {
  if: 10,
  id: 999,
  bind: 1e3,
  data: 1e3,
  l10n: 1e3,
  focus: 1e3,
  autofocus: 1e3,
  ref: 1e3,
  cloak: 1e3,
  text: 1500,
  prune: 1500,
  html: 1500,
  model: 1500,
  modelable: 1500,
  value: 1500,
  on: 1500,
  mask: 1500,
  id: 1600,
  effect: 2e3,
  for: 3e3,
  transition: 3500,
  show: 4e3
};
class Alpine {
  constructor() {
    // static start() { }
    this.components = {};
    this.$store = {};
  }
  // Static properties
  static get reactive() {
    return Alpine.getReactiveEngine().reactive;
  }
  static get release() {
    return Alpine.getReactiveEngine().release;
  }
  static get effect() {
    return Alpine.getReactiveEngine().effect;
  }
  static get raw() {
    return Alpine.getReactiveEngine().raw;
  }
  static get version() {
    return "3.13.0";
  }
  // Static methods
  static getReactiveEngine() {
    try {
      return {
        reactive,
        effect,
        release,
        raw
      };
    } catch (error) {
      throw new Error("Alpine's reactive engine was attempted to be used but it's not available.");
    }
  }
  static skipDuringClone(callback, fallback = () => {
  }) {
    return shouldSkipRegisteringDataDuringClone ? fallback : callback;
  }
  static onBeforeDeletedNode(node, callback) {
    const onbeforeNodesDeleted = (_nodes) => {
      const nodes = [..._nodes].reverse();
      for (const node2 of nodes) {
        if (node2.isEqualNode(node)) {
          callback();
        }
      }
    };
    const observer = new MutationObserver((mutations) => {
      for (const mutation of mutations) {
        if (mutation.type === "childList") {
          onbeforeNodesDeleted(mutation.removedNodes);
        }
      }
    });
    observer.observe(node.parentElement, { childList: true });
    return () => observer.disconnect();
  }
  static onReady(callback) {
    if (document.readyState !== "loading") {
      callback();
    } else {
      document.addEventListener("DOMContentLoaded", callback);
    }
  }
  static documentObserver(callback) {
    const observer = new MutationObserver((mutations) => {
      for (const mutation of mutations) {
        if (mutation.type === "childList") {
          callback(mutation.addedNodes, mutation.removedNodes, mutation);
        }
      }
    });
    Alpine.onReady(() => {
      observer.observe(document.documentElement, {
        childList: true,
        subtree: true
      });
    });
    return () => observer.disconnect();
  }
  static nodeWalkIn(node, callback) {
    const inspect = (child) => {
      if (callback(child) === true)
        return;
      Alpine.nodeWalkIn(child, callback);
    };
    for (const child of node.childNodes) {
      inspect(child);
    }
  }
  static nodeWalkOut(node, callback) {
    while (node.parentElement) {
      node = node.parentElement;
      callback(node);
    }
  }
  static nodeWalkUp(node, callback) {
    const rootParent = document.documentElement;
    const matches = [];
    let target = node;
    while (target !== null && target.parentElement && target.parentElement !== rootParent) {
      let parent = target.parentElement;
      if (parent === null) {
        break;
      }
      matches.push(parent);
      target = parent;
    }
    for (const parent of matches) {
      callback(parent);
    }
  }
  static nodeOuts(node, callback) {
    let target = node;
    if (target.nodeType !== 1)
      target = target.parentElement;
    while (target !== null) {
      const next = target.parentElement;
      callback(target);
      if (next === document.documentElement)
        break;
      target = next;
    }
  }
  static onAttributesAdded(node, attributeNames, callback) {
    const observer = new MutationObserver((mutations) => {
      for (const mutation of mutations) {
        if (mutation.type === "attributes" && mutation.target === node && attributeNames.includes(mutation.attributeName) && node.hasAttribute(mutation.attributeName)) {
          callback(mutation.attributeName, node, observer);
        }
      }
    });
    observer.observe(node, { attributes: true, attributeFilter: attributeNames });
    for (const attribute of attributeNames) {
      if (node.hasAttribute(attribute))
        callback(attribute, node, observer);
    }
    return () => observer.disconnect();
  }
  static onElRemoved(el, callback, observerOptions = { childList: true, subtree: true }) {
    const observer = new MutationObserver((mutations) => {
      for (let i = 0; i < mutations.length; i++) {
        if (mutations[i].type === "childList") {
          const nodes = [...mutations[i].removedNodes];
          if (nodes.includes(el) || nodes.some((node) => node.contains(el))) {
            callback();
          }
        }
      }
    });
    if (document.body.contains(el)) {
      Alpine.onReady(() => {
        observer.observe(document.documentElement, observerOptions);
      });
      return () => observer.disconnect();
    } else {
      callback();
      return () => {
      };
    }
  }
  static throttle(func, limit = 400) {
    let inThrottle;
    return function(...args) {
      const context = this;
      if (!inThrottle) {
        func.apply(context, args);
        inThrottle = true;
        setTimeout(() => inThrottle = false, limit);
      }
    };
  }
  static debounce(func, wait = 400) {
    let timeout;
    return function executedFunction(...args) {
      const later = () => {
        clearTimeout(timeout);
        func(...args);
      };
      clearTimeout(timeout);
      timeout = setTimeout(later, wait);
    };
  }
  static nextFrame(callback) {
    requestAnimationFrame(() => requestAnimationFrame(callback));
  }
  static dispatch(el, name, detail = {}, bubbles = true) {
    el.dispatchEvent(
      new CustomEvent(name, {
        detail,
        bubbles,
        // For custom events to be cancelable, we need to set this to true.
        cancelable: true,
        composed: true
      })
    );
  }
  static dispatchTo(name, detail = {}) {
    document.dispatchEvent(
      new CustomEvent(name, {
        detail,
        bubbles: true,
        cancelable: true,
        composed: true
      })
    );
  }
  static trigger(el, name, data = {}) {
    Alpine.dispatch(el, name, data);
  }
  static isElementInViewport(el, options = { intersectionRatio: 0, rootMargin: "0px" }) {
    const rect = el.getBoundingClientRect();
    if (typeof IntersectionObserver !== "undefined") {
      return new Promise((resolve) => {
        const observer = new IntersectionObserver(
          ([entry]) => {
            resolve(entry.isIntersecting);
            observer.disconnect();
          },
          options
        );
        observer.observe(el);
      });
    }
    return Promise.resolve(
      rect.top >= 0 && rect.left >= 0 && rect.bottom <= (window.innerHeight || document.documentElement.clientHeight) && rect.right <= (window.innerWidth || document.documentElement.clientWidth)
    );
  }
  static onInView(el, callback, options = { intersectionRatio: 0, rootMargin: "0px" }) {
    const observer = new IntersectionObserver(
      (entries, observer2) => {
        entries.forEach((entry) => {
          if (entry.isIntersecting) {
            callback(entry);
          }
        });
      },
      options
    );
    observer.observe(el);
    return () => observer.disconnect();
  }
  static asyncEach(array, callback) {
    return array.reduce(
      (promise, item, index) => promise.then(() => callback(item, index, array)),
      Promise.resolve()
    );
  }
  static asyncMap(array, callback) {
    return Promise.all(array.map(callback));
  }
  static asyncFilter(array, callback) {
    return Alpine.asyncMap(array, callback).then((results) => array.filter((_, i) => results[i]));
  }
  static onClickOutside(elements, callback, eventHandler = null) {
    const handleEvent = (event) => {
      const targets = Array.isArray(elements) ? elements : [elements];
      const isOutside = !targets.some((element) => {
        return element.contains(event.target) || event.target === element;
      });
      if (isOutside) {
        callback(event);
      }
    };
    const removeEventListener = () => {
      document.removeEventListener("click", eventHandlerWrapper);
      document.removeEventListener("focusin", eventHandlerWrapper);
    };
    const eventHandlerWrapper = eventHandler || handleEvent;
    document.addEventListener("click", eventHandlerWrapper);
    document.addEventListener("focusin", eventHandlerWrapper);
    return removeEventListener;
  }
  static evaluate(el, expression, extras = {}) {
    let result;
    evaluateLater(el, expression)((value) => result = value, extras);
    return result;
  }
  static evaluateLater(...args) {
    return evaluateLater(...args);
  }
  static plugin(callback) {
    callback(Alpine);
  }
  static magic(name, callback) {
    Alpine.addMagicProperty(name, callback);
  }
  static store(name, value) {
    if (value === void 0) {
      return Alpine.$store[name];
    }
    Alpine.$store[name] = value;
  }
  static bind(name, callback) {
    Alpine.addBinding(name, callback);
  }
  static data(name, callback) {
    Alpine.addData(name, callback);
  }
  static directive(name, callback, modifierCallback) {
    Alpine.addDirective(name, callback);
  }
  static start() {
    Alpine.documentObserver((addedNodes) => {
      for (const node of addedNodes) {
        if (node.nodeType === 1) {
          if (node.hasAttribute("x-data")) {
            initTree(node, true, true);
          }
        }
      }
    });
    if (!document.querySelector("[x-data]")) {
      console.warn("Alpine.js: No root element with [x-data] directive found.");
    }
    for (const el of document.querySelectorAll("[x-data]")) {
      initTree(el, true, true);
    }
  }
}

return Alpine;

});
